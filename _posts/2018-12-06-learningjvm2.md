---
layout: post
title:  "垃圾收集器和内存分配策略"
subtitle: "JVM笔记2"
header-img: "img/post-bg-universe.jpg"
tag: 
    - JVM笔记
---
**目录**
* content
{:toc}

程序计数器，虚拟机栈，本地方法栈这3个区域随线程而生，随线程而灭；栈中的栈帧随方法进入和退出有条不紊地执行出栈和入栈操作。每一栈帧中分配的内存基本上从类结构确定下来就已知。所以这几个区域就**不需要过多考虑回收**的问题，因为方法结束或者线程结束时，内存自然就跟随回收了。而**Java堆和方法区**则不一样，这部分的内存的分配与回收都是动态的,`垃圾回收器`重点关注的是这里的内存。

# 对象已死吗
垃圾回收器对堆进行回收前，第一时间就是要确定这些对象之中哪些还“存活”着。
## 引用计数算法
**方法**：给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；引用失效则减1；任何时刻计数器为0的对象就是不可能再被使用的。  
`缺点`：不能解决相互循环引用问题。
{% highlight ruby %}
public class Sample{
    public Object instance = null;
    private static final int _1MB = 1024*1024;
}
/**
 *这个成员的作用就是占点内存
 */
private byte[] BigSize = new byte[2 * _1MB];

public static void testGC(){
    Sample objA = new Sample();
    Sample objB = new Sample();

    objA.instance = objB;
    objB.instance = objA;

    objA = null;
    objB = null;
    
    System.gc();
    /**
    *事实上是，在这之后，objA和objB被回收了，
    *因此我们可以确定Java并不是用的引用计数算法
    */
}
{% endhighlight %}

## 可达性分析算法
现在的主流应用程序语言（包括Java）都是通过可达性分析（Reachability Analysis）来判定对象是否存活的。  
**方法**：通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径被称为`引用链`,当一个对象到GC Roots没有任何引用链相连时，证明此对象**不可用**。
![](\img\in-post\L-JVM\JVM2-1.PNG)
以下几种对象可以作为GC Roots:  
1. 虚拟机栈(栈帧中的本地变量表)中引用的对象。
2. 方法区中类静态属性引用的对象。
3. 方法区中常量引用的对象。
4. 本地方法栈中JNI（Native方法）引用的对象。

## 再谈引用
Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference），软引用（Soft Reference），弱引用（Weak Reference），虚引用（Phantom Reference）4种，引用强度依次递减。  
* 强引用指程序代码中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾回收器永远不会回收掉被引用的对象。
* 软引用用来描述一些还有用但非必需的对象。在系统快要发生`内存溢出`异常之前，将会将这些对象进行第二次回收，如果还没有足够内存，会抛出内存溢出异常。
* 弱引用关联对象只能生存到`下一次垃圾收集`发生之前。
* 虚引用是最弱的引用关系，一个对象是否有虚引用对自身完全不构成影响，也无法通过虚引用获得实例。仅用来能在引用虚引用的对象被收集器回收时受到一个系统通知。

## 生存还是死亡
真正宣告一个对象的死亡要经过`两次`标记过程：  
1. 如果对象在可达性分析后发现没有与GC Roots相连的引用链，那么它将会被第一次标记并且进行一次筛选。  
2. 筛选的条件是此对象是否有必要执行`finalize（）`方法。当对象没有覆盖finalize方法，或者finalize方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。
3. 如果一个对象被视为“有必要执行”finalize方法，那么对象将会被放置到一个叫做F-Queue的队列中。并在稍后由一个虚拟机自动建立、低优先级的Finalizer线程去执行它。这里的执行不代表会等待运行结束，如果一个对象执行缓慢或者发生死循环就是另外一种情况了。
4. 在执行finalize方法的过程中，是对象`最后一次`拯救自己的机会，对象如果在finalize方法中重新与引用链上的一个对象建立关联，则被移除出**即将回收**的集合。如果这个时候还没有建立关联，那么它就真的被回收了。需要注意的是，finalize方法对于任何对象来说都只会被系统自动调用`仅一次`。并且不建议在代码的编写中，用这个方法。

## 回收方法区
永久代主要回收两部分内容：**废弃常量**和**无用的类**。  
* 回收废弃常量的方法与Java堆中的对象类似。比如一个字符串“abc”已经进入常量池，而在当前系统没有任何一个String对象叫做“abc”，换句话说，没有任何一个String对象引用常量池中的“abc”常量，也没有其他地方引用这个字面量，这个时候进行内存回收，如果有必要，它将会被清理出常量池。
* 判定一个类是否为**无用的类**，条件就要苛刻了许多。要`同时满足`下面三个条件。
1. 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。
2. 加载该类的ClassLoader已经被回收。
3. 该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。

# 垃圾回收算法
## 标记-清除算法
![](\img\in-post\L-JVM\JVM2-2.PNG)
**思路**：首先标记所有需要回收的方法，然后在标记完成后统一回收所有被标记的对象。  
`缺点`:标记和清除两个过程的效率都不高；标记清除后，会产生大量不连续的内存碎片，空间碎片太多会导致以后在程序运行过程中需要分配大的对象时，无法找到匹配大小的连续内存，从而不得不提前触发另一次垃圾回收操作。
## 复制算法
![](\img\in-post\L-JVM\JVM2-3.PNG) 
**思路**：将可用内存分为大小相等的两块，每次只使用其中的一块。当一块的内存用完了，就将还活着的对象复制到另一块上面，然后把已使用的内存空间清理掉。  
`注意`:  
* 当前的商业虚拟机都采用这种收集方法收集新生代。
* 实际运用中，并不是按照1：1的方法，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。默认比例为8：1：1.
## 标记-整理算法
![](\img\in-post\L-JVM\JVM2-4.PNG) 
**思路**：标记清除的过程仍然与标记-清除算法一样，但后续是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。  
`注意`：
* 在老年代一般选用这种算法
## 分代收集算法
当前商业虚拟机都采用**分代收集算法**（Generational Collection）算法，这种算法根据对象的存活周期将内存划分为几块。一般是将对象分为新生代和老年代。  
**新生代**：每次收集都发现有大批对象死去，只有少量存活，那就选用复制算法。  
**老年代**：存活率高，没有额外空间对它进行担保，就必须选择标记-整理或者标记-清理算法来进行回收。

# HotSpot的算法实现