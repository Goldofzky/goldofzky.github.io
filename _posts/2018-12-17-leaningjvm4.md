---
layout: post
title:  "虚拟机字节码执行引擎"
subtitle: "JVM笔记4"
header-img: "img/post-bg-universe.jpg"
tag: 
    - JVM笔记
---
**目录**
* content
{:toc}

# 概述
* 输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。  
# 运行时栈帧结构
![](\img\in-post\L-JVM\JVM4-1.PNG)  
* 栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构。它是虚拟机运行时数据区中的`虚拟机栈`的栈元素。
* 存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。
* 在编译程序代码时，栈帧中需要多大的局部变量表、多深的操作数栈`已经完全确定`，并且写入方法表的Code属性中。因此栈帧需要分配多少内存，不会受到程序运行期变量数据的影响。仅仅取决于具体的虚拟机实现。
## 局部变量表
* 是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。
* 最小单位为`变量槽`(Variable Slot)。虚拟机规范中说明每个Slot都应该能存放一个boolean、byte、char、short、int、float、reference或returnAdderss类型的数据。每个Slot可以存放一个32位以内的数据类型。对于64位的数据类型(long、double)，虚拟机会以高位在前的方式为其分配两个连续的Slot空间。
* 虚拟机采用`索引定位`的方式来使用局部变量表。
* 在方法执行时，虚拟机使用局部变量表完成参数值到参数变量列表的传递过程，如果是实例方法，那么局部变量表第0位索引的Slot默认是用于传递方法所属对象的引用，在方法中可以通过“this”来访问这个隐含参数。
* 类变量因为有两次赋初始值的过程，所以有准备阶段的默认初始，所以在初始化阶段即使不赋值也没关系。但是局部变量必须要有一个初始值，否则编译会报错。
* Slot是可重用的，并不一定会覆盖整个方法体，如果PC计数器超出某个变量的作用域，那么这个变量对应的Slot就可以交给其他变量使用。
## 操作数栈
* 也被称为操作栈，是一个后进先出栈，其最大深度在编译时便已经确定。
* 32位数据栈容量为1，64位数据栈容量为2。
* 在方法刚开始进行时，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令向操作数栈中写入和提取内容，也就是出栈入栈操作。例如在进行算术运算和调用其他方法的时候时通过操作数栈来进行的。    
`例子`   
>整数加法的字节码指令iadd在运行的时候要求操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值，当执行这个指令时，会将这两个int值出栈并相加，然后将相加的结果入栈。
* 操作数栈中的元素类型必须与字节码指令的序列严格匹配，在编译程序代码的时候，编译器要严格保证。
* 大多数虚拟机实现中会让两个栈帧出现一部分`重叠`，让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，状态在进行方法调用时就可以公有一部分数据，而无需进行额外的参数传递。
* Java虚拟机的解释引擎称为**基于栈的执行引擎**，这里的`栈`就是指操作数栈。
## 方法返回地址
* 当一个方法被执行后，有两种方法退出这个方法：  
1. **正常完成出口：(Normal Method Invacation Completion)**执行引擎遇到任意一个方法返回的字节码指令，这时可能会有返回值传递给上层的方法调用者，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定。
2. **异常完成出口：(Abrupt Method Invocation Completion)**在方法执行过程中遇到了异常，并且这个异常没有在方法体得到异常处理，在本方法的异常表没有搜索到匹配的异常处理器，就会导致方法退出，不会给它的上层调用者返回任何返回值。
* 一般来说，方法正常退出时，调用者的PC计数器的值就可以作为返回值，栈帧中很可能保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。
* 方法退出的过程实际上等同于`当前栈帧出栈`，因此退出可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值(如果有的话)压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。
## 附加信息
* 虚拟机规范允许具体的虚拟机实现增加一些规范中没有描述的信息到栈帧中，例如与调试有关的信息，这部分信息完全取决于具体的虚拟机实现。一般把动态连接，方法返回信息与其他附加信息全部归为一类，称为`栈帧信息`。
# 方法调用
* 方法调用阶段唯一的任务就是确定被调用方法的版本(即调用哪一个方法)。
## 解析
* 方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。这类方法的调用称为`解析`(Resolution)。
* 满足以上条件的方法主要有`静态方法`和`私有方法`两大类。前者与类型直接关联，后者在外部不可被方法。它们都不可能通过继承或别的方式重写出其他版本。
* 
