---
layout: post
title: "Bit-map"
subtitle: "Bit-map(位图与海量数据处理)"
author: "KeYu"
header-style: text
tags:
  - 算法
  - 海量数据处理
---
> MapReduce是一种编程模型，用于大规模数据集（大于1TB）的并行运算。概念"Map（映射）"和"Reduce（归约）"

# 基本思想
* 使用一个bit位来标记某个元素对应的value，而key就是该元素在若干bit中的位置。这样大大节省了存储空间。
![](/img/in-post/Bit-map.PNG)
# 应用
## 排序
* 对于海量的无重复密集元素排序，其有着占用少的优点。
* 步骤：
    1. 将Bit-map所有bit置为1
    2. 将第一个value为n的元素放进Bit-map中(将第n位bit置为1)
    3. 按照以上方法，放进所有元素
    4. 从Bit-map的第一位开始遍历，若为1则输出。

* 其排序的时间由最大的那一位数MAX决定，需要的内存大小为(MAX/一个字节的位数)字节。

## 去重
找出2.5亿个数中的不重复的整数个数内存不足以容纳这2.5亿个整数
1.  用Bit-map来存储数字的状态，用两位来存储一个数字的状态。
2.  若没有这个数则为00，有一个为01，一个以上为11。
3.  遍历这2.5亿个数字，如果对于状态位为00，则变为01；若状态位为01，则变为11；若为11，则状态位不变。
4.  最后将状态位为01的进行统计，就得到了不重复的数字个数。

## 查询
快速判断一个数字是否存在在上述的2.5亿个整数中
1. 同之前一样，首先我们先对所有的数字进行一次遍历，然后将相应的转态位改为1。
2. 遍历完以后就是查询，由于我们的Bit-map采取的是连续存储（整型数组形式，一个数组元素对应32bits）
3. 我们实际上是采用了一种分桶的思想。一个数组元素可以存储32个状态位，那将待查询的数字除以32，定位到对应的数组元素（桶），然后再求余（%32），就可以定位到相应的状态位。如果为1，则代表改数字存在；否则，该数字不存在。

## 布隆过滤器
* 直观的说，bloom算法类似一个hash set，用来判断某个元素（key）是否在某个集合中。
和一般的hash set不同的是，这个算法无需存储key的值，对于每个key，只需要k个比特位，每个存储一个标志，用来判断key是否在集合中。(有一定的误判性)
* 优点在于其不需要存储key，节省空间。
* 算法
  1. 首先需要k个hash函数，每个函数可以把key散列成为1个整数
  2. 初始化时，需要一个长度为n比特的数组，每个比特位初始化为0
  3. 某个key加入集合时，用k个hash函数计算出k个散列值，并把数组中对应的比特位置为1
  4. 判断某个key是否在集合时，用k个hash函数计算出k个散列值，并查询数组中对应的比特位，如果所有的比特位都是1，认为在集合中。
![](/img/in-post/BloomFilter.png)
# 总结
* 通过Bit-map思想，我们可以将存储空间进行压缩，对数字进行排序、去重、查询等操作。