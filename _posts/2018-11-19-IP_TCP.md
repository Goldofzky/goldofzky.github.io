---
layout: post
title:  "TCP/IP理解"
subtitle: "Principle of TCP/IP"
header-img: "img/about-bg-walle.jpg"
tag: 
    - 网络原理
---
* content
{:toc}


# IP

在谈到传输协议前必须要先理解`IP`(Internet Protocal，互联网协议)的基本概念。  
IP包含两个基本的功能，**寻址**和**分片**。
两个电话拨通，我们需要知道两个电话之间的电话号码，而主机之间的通讯也一样，每一个连上Internet的主机都至少要有一个IP地址，从而将自己与其他网络上的主机区分开来。
>源主机必须要知道目标主机的IP地址才能向其发送数据。源主机可以向已知IP地址的目的主机发送数据包，并借助于网络设备寻找到达目的主机的路径，最终将数据包发送到目的地，这个过程即为`寻址`。

>当发送数据时，信息将被拆分为若干个小块，称为**数据包**。IP协议在传输数据包时，将数据报文分为若干分片进行传输，并在目标系统中进行重组。
不同的链路类型规定有不同最大长度的链路层数据帧，称为链路层MTU（最大传输单元）。常见以太网的MTU为1500，若IP协议在传输数据包时，IP报文长度大于转发接口的MTU，则将数据报文分为若干`分片`进行传输，分片报文到达接收方时，由接收方完成重组。  
>因为数据包可以通过Internet不同的路径到达目的地址，所以数据包到达目的地址的顺序可能与发送时的顺序不同。IP只负责发送数据包，而TCP负责将数据包按照正确的顺序进行排序。
![IP数据包的格式](\img\in-post\IP-bag.jpg)

IP的服务模型是**尽力而为交付服务**，意味着IP尽自己最大的努力交付报文段，但是它*并不做任何担保*。不确保文段的交付，不能保证文段的顺序正确，因为这些原因，IP被称为**不可靠服务**。而随着TCP的引入，保证了文段传输的`可靠性`。

# 运输层的多路复用和多路分解

UDP以及TCP的主要作用：将两个端系统间IP的交付服务扩展为进程之间的交付服务。我们将主机间交付扩展到进程到进程交付，称为运输层的`多路复用`与`多路分解`。
在应用层与运输层之间有着由软件实现的`端口`。各进程之间通过`套接字`，将进程之间交流的信息从自己的端口和目的的端口连接起来。我们可以把主机看作一个房子，而套接字则是门，它相当于从网络向进程传递数据和从进程向网络中传递数据的门户。我们的主机在任何一个时刻，主机上都有多个套接字，而套接字都有可以唯一标识自己的标识符。

## 多路复用
那么什么叫做多路复用呢，我们将不同的套接字中的数据段收集起来，并且在每一个每一个数据块封装上首部信息（这将在多路分解中使用）从而生成报文段。  
>这个过程类似于将一个城市的信件放入邮件车中。信件上有一系列的信息，寄信人，收信人等。

## 多路分解
将运输层报文段中的数据交付到正确的套结字上的工作被称为多路分解。
>这个过程类似于邮件车到达了目标城市，然后根据信件上的地址将信件投放到指定的客户手上。这里的客户即是目标套接字。

# 逐步解决可靠运输
在这里我们介绍rdt（Reliable Data Transfer）协议，即`可靠数据传输协议`的逐步完善。
## 假如底层通道完全可靠(rdt1.0)
我们首先考虑最简单的情况，即底层通道完全可靠，不会发生错误，此时将协议定为rdt1.0。此时发送方和接受方的状态如下。  
`rdt1.0发送方`  
![rdt1.0发送方](\img\in-post\tcp_ip\rdt1-1.PNG)
发送方仅有一个状态，通过rdt_send来接受高层的数据，进行**分路复用**，将packet发送至接收方。
`rdt1.0接收方`  
![rdt1.0接收方](\img\in-post\tcp_ip\rdt1-2.PNG)
接收方也只有一个状态，它通过rdt_rcv从较底层接收packet，进行**分路分解**,将data发送到较高层。 
## 引入比特差错(rdt2.0) 
在底层通道传输的过程中，实际上分组中的比特可能受损。若还是像rdt1.0那样是无法保证运输的都是没有出比特差错的信息的。  
为了解决这个问题我们还需要另外三种协议来处理这种差错:
>**1.差错检测**：我们需要一种机制来检测我们什么时候出现了比特差错。  
**2.接受方反馈**：发送方和接受方不在同一个系统上运行，若是接受方检测到错误后不作出反馈，那么发送方并不知道自己传输的过程中出现了比特差错。我们引入了肯定确认(ACK)和否定确认(NAK)来反馈。我们的rdt2.0从接收方向像发送方会送ACK和NAK分组来表示是否发生差错。  
**3.重传**：如果发生比特差错，发送方需要进行一次重传。

`rdt2.0发送方`  
![rdt2.0发送方](\img\in-post\tcp_ip\rdt2-1.PNG)
rdt2.0发送与rdt1.0的不同点在于，发送方多了一个等待ACK的状态，并且不只是单纯的将data进行make_pkt操作，而是计算出校验和，在原来packet的基础上加上**校验**位，产生新的sndpkt，可以让接收方实现校验功能。   
`rdt2.0接收方`    
![rdt2.0接收方](\img\in-post\tcp_ip\rdt2-2.PNG)
与以前相比，接收方会将接收的sndpkt进行校验，并向发送方反馈。

但是有一点我们需要考虑，接收方发出的反馈也有比特差错的可能性。因此反馈也应当加上校验供发送方检查。而需要解决的问题是：接收方应当怎么样才能确认自己发送的反馈发送了错误，而发送方发给自己的是一次重传而不是下一个分组呢。我们解决这个问题的方法是为数据分组添加新的字段----**序号**。于是接收方只需要检查序号便知道确认是否是一次重传。  
`rdt2.1发送方`    
![rdt2.1发送方](\img\in-post\tcp_ip\rdt2-3.PNG)
可以发现发送多了两个状态，并且在发送的sndpkt中加入了序号来表示是哪一次发送的分组，且ACK和NAK也进行了校验检测，判断是否有比特错误。  
`rdt2.1接收方`      
![rdt2.1接收方](\img\in-post\tcp_ip\rdt2-4.PNG)
若是在等待时，传来的分组与自己想要等待的不同，那么可以确定，这是发送方发来的重传，我们需要再次检验并且反馈。  

在原来的基础上，我们因为序号的引入。从而可以不发送NAK也能够确认是否需要重传。发送方如果接受到了对同一个分组的两个ACK（即`冗余ACK`）后，就知道接收方没有正确接受到跟在被确认两次分组后面的分组。rdt2.2是具有比特差错信道上实现的无NAK的可靠运输协议。变化在于接收方必须包括一个ACK报文确认的分组序号，发送方必须检查收到的ACK的序号来处理冗余分组情况。   
`rdt2.2发送方`      
![rdt2.2发送方](\img\in-post\tcp_ip\rdt2-5.PNG)
`rdt2.2接收方`        
![rdt2.2接收方](\img\in-post\tcp_ip\rdt2-6.PNG)

## 引入丢包(rdt3.0)
从发送方的观点来看，重传是一种万能的方法。发送方不知道是一个数据分组的丢失,ACK丢失还是过度的时延。在所有的情况下，发送方的解决方案都是一样的，那就是重传。为了实现基于时间的重传机制，我们需要一个**倒计时定时器**。在一个给定的时间过期后，可以中断发送方。发送方需要满足几点要求：  
>1.每次发送一次分组，便启动一个定时器。  
2.响应定时器的中断  
3.终止定时器

`rdt3.0发送方`      
![rdt3.0发送方](\img\in-post\tcp_ip\rdt3-1.PNG)
在这里归纳我们所用到的要点。**校验和，序号，定时器，肯定确认和否定确认**，这些机制的共同合作下终于得到了一个有效的可靠数据传输协议！虽然是一个停等协议（每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组），但为TCP协议的完善建立了基础。  

## 流水线可靠数据传输运输协议
若是用停等协议，完全可以想象，这样对于发送方的利用率将极低，因为总是处于等待的状态下。性能根本无法满足我们的需要，若是我们要解决这个问题，我们就不应该采用停等的方式来运行，应当允许发送方发送多个分组而不需等待确认。  
若要完成这一需求：  
>1.必须增加序号的范围，因为每一个传输的分组都必须有一个唯一的序号。  
2.协议的发送方和接收方必须缓存多个分组。  
3.对处理丢失，损坏以及过度延时分组的解决方案。 

# TCP协议
>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。  

## TCP首部格式
![TCP](\img\in-post\tcp_ip\tcp.png)
-  **序号**  ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。

-  **确认号**  ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。

-  **数据偏移**  ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。

-  **确认 ACK**  ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。

-  **同步 SYN**  ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。

-  **终止 FIN**  ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。

-  **窗口**  ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。

## TCP 的三次握手
![TCP](\img\in-post\tcp_ip\tcp1.png)
假设 A 为客户端，B 为服务器端。

- 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。

- A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。

- B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。

- A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。

- B 收到 A 的确认后，连接建立。

**三次握手的原因** 

第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。

## TCP 的四次挥手
![TCP](\img\in-post\tcp_ip\tcp2.jpg)
以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。

- A 发送连接释放报文，FIN=1。

- B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。

- 当 B 不再需要连接时，发送连接释放报文，FIN=1。

- A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。

- B 收到 A 的确认后释放连接。

**四次挥手的原因** 

客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

**TIME_WAIT** 

客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：

- 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。

- 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

## TCP片段丢失（丢包）
接收方(receiver)可以通过校验TCP片段头部中checksum区域来检验TCP片段是否出错。我们已经接触过了IP协议详解的checksum算法。TCP片段的checksum算法与之类似。IP协议的checksum只校验头部，TCP片段头部的checksum会校验包括IP头部、TCP头部和TCP数据在内的整个序列，确保IP地址、端口号和其他相关信息正确。如果TCP片段出错，接收方可以简单的丢弃该TCP片段，也就相当于TCP片段丢失。

TCP片段包裹在一个IP包中传输。IP包可能在网络中丢失。导致IP包丢失的原因可能有很多，比如IP包经过太多的路由器接力，达到hop limit；比如路由器太过拥挤，导致一些IP包被丢弃；再比如路由表(routing table)没有及时更新，导致IP包无法送达目的地。  

而产生丢包对于发送方来说，最直观的现象有两种：    
**1.超时**  
**2.收到来自接受方的三次冗余ACK**      
解决方案也无一例外，也就是`重传`，不过有一些小小的差别，下面将会提到。

## TCP拥塞控制

>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度  

为了使TCP拥有拥塞控制机制，于是连接的每一端都记录一个额外的变量，即`拥塞窗口`（CongWin）,它对TCP分组的传输速率进行了限制。一个发送方的中未被确认的量一定不能大于CongWin。
### 加性增，乘性减(AIMD)
当TCP在传输时发生丢包事件时，在重传的同时，CongWin的大小也发生变化，每次丢包事件都将导致CongWin的大小减半，而后分组每成功传输一次，CongWin的大小加1个MSS(最大报文段长度)，所以被称作**加性增，乘性减**。
![AIMD](\img\in-post\tcp_ip\AIMD.PNG)  
由上图可以直观看出CongWin的大小变化。  
### 慢启动
当一个TCP连接开始时，CongWin的大小从一个MSS开始，每过一个RTT就将CongWin的大小翻倍，直到第一个丢包事件发生。
![](\img\in-post\tcp_ip\slow-start.PNG)  
由图，TCP传输从每次一个报文段，慢慢地随着2的指数倍增长。

### 超时重传
![](\img\in-post\tcp_ip\overtime.PNG)  
当超时事件发生后，发送方进行重传，而CongWin的大小将会重新便为1，重新进入**慢启动**状态，直到达到上次丢包时CongWin的一半（这个值TCP通过一个称为`阈值`的变量来维护），然后开始进入拥塞避免阶段，开始线性增长。

### 快速重传和快速恢复
![](\img\in-post\tcp_ip\3ack.PNG)  
当发送方连续收到3次冗余ACK时，即发生丢包事件，进行重传。在以前的TCP版本中，无论是超时还是收到3次冗余ACK都是进行慢启动（TCP Tahoe）。在较新版本的TCP （`TCP Reno`）中是这样的,CongWin变为原来的一半。取消慢启动的原因在于，在收到3次冗余ACK时其实另外的报文段已经被接受方收到了。因此它与超时事件不同，网络显示它自己可以交付一些报文段，即使其他报文段因为拥塞丢失了。这种收到3次冗余ACK取消慢启动的行为叫做快速恢复。    
![](\img\in-post\tcp_ip\TCP-history.PNG)  

