---
layout: post
title:  "TCP/IP理解"
subtitle: "Principle of TCP/IP"
header-img: "img/about-bg-walle.jpg"
tag: 
    - 网络原理
---
* content
{:toc}


# IP

在谈到传输协议前必须要先理解`IP`(Internet Protocal，互联网协议)的基本概念。  
IP包含两个基本的功能，**寻址**和**分片**。
两个电话拨通，我们需要知道两个电话之间的电话号码，而主机之间的通讯也一样，每一个连上Internet的主机都至少要有一个IP地址，从而将自己与其他网络上的主机区分开来。
>源主机必须要知道目标主机的IP地址才能向其发送数据。源主机可以向已知IP地址的目的主机发送数据包，并借助于网络设备寻找到达目的主机的路径，最终将数据包发送到目的地，这个过程即为`寻址`。

>当发送数据时，信息将被拆分为若干个小块，称为**数据包**。IP协议在传输数据包时，将数据报文分为若干分片进行传输，并在目标系统中进行重组。
不同的链路类型规定有不同最大长度的链路层数据帧，称为链路层MTU（最大传输单元）。常见以太网的MTU为1500，若IP协议在传输数据包时，IP报文长度大于转发接口的MTU，则将数据报文分为若干`分片`进行传输，分片报文到达接收方时，由接收方完成重组。  
>因为数据包可以通过Internet不同的路径到达目的地址，所以数据包到达目的地址的顺序可能与发送时的顺序不同。IP只负责发送数据包，而TCP负责将数据包按照正确的顺序进行排序。
![IP数据包的格式](\img\in-post\IP-bag.jpg)

IP的服务模型是**尽力而为交付服务**，意味着IP尽自己最大的努力交付报文段，但是它*并不做任何担保*。不确保文段的交付，不能保证文段的顺序正确，因为这些原因，IP被称为**不可靠服务**。而随着TCP的引入，保证了文段传输的`可靠性`。

# 运输层的多路复用和多路分解

UDP以及TCP的主要作用：将两个端系统间IP的交付服务扩展为进程之间的交付服务。我们将主机间交付扩展到进程到进程交付，称为运输层的`多路复用`与`多路分解`。
在应用层与运输层之间有着由软件实现的`端口`。各进程之间通过`套接字`，将进程之间交流的信息从自己的端口和目的的端口连接起来。我们可以把主机看作一个房子，而套接字则是门，它相当于从网络向进程传递数据和从进程向网络中传递数据的门户。我们的主机在任何一个时刻，主机上都有多个套接字，而套接字都有可以唯一标识自己的标识符。

## 多路复用
那么什么叫做多路复用呢，我们将不同的套接字中的数据段收集起来，并且在每一个每一个数据块封装上首部信息（这将在多路分解中使用）从而生成报文段。  
>这个过程类似于将一个城市的信件放入邮件车中。信件上有一系列的信息，寄信人，收信人等。

## 多路分解
将运输层报文段中的数据交付到正确的套结字上的工作被称为多路分解。
>这个过程类似于邮件车到达了目标城市，然后根据信件上的地址将信件投放到指定的客户手上。这里的客户即是目标套接字。

# 逐步解决可靠运输
## 假如底层通道完全可靠
我们首先考虑最简单的情况，即底层通道完全可靠，不会发生错误，此时将协议定为rdt1.0。此时发送方和接受方的状态如下。  
`rdt1.0发送方`  
![rdt1.0发送方](\img\in-post\tcp_ip\rdt1-1.PNG)
发送方仅有一个状态，通过rdt_send来接受高层的数据，进行**分路复用**，将packet发送至接收方。
`rdt1.0接收方`  
![rdt1.0接收方](\img\in-post\tcp_ip\rdt1-2.PNG)
接收方也只有一个状态，它通过rdt_rcv从较底层接收packet，进行**分路分解**,将data发送到较高层。 
## 引入比特差错
在底层通道传输的过程中，实际上分组中的比特可能受损。若还是像rdt1.0那样是无法保证运输的都是没有出比特差错的信息的。  
为了解决这个问题我们还需要另外三种协议来处理这种差错:
>**1.差错检测**：我们需要一种机制来检测我们什么时候出现了比特差错。  
**2.接受方反馈**：发送方和接受方不在同一个系统上运行，若是接受方检测到错误后不作出反馈，那么发送方并不知道自己传输的过程中出现了比特差错。我们引入了肯定确认(ACK)和否定确认(NAK)来反馈。我们的rdt2.0从接收方向像发送方会送ACK和NAK分组来表示是否发生差错。  
**3.重传**：如果发生比特差错，发送方需要进行一次重传。

`rdt2.0发送方`  
![rdt2.0发送方](\img\in-post\tcp_ip\rdt2-1.PNG)
rdt2.0发送与rdt1.0的不同点在于，发送方多了一个等待ACK的状态，并且不只是单纯的将data进行make_pkt操作，而是计算出校验和，在原来packet的基础上加上**校验**位，产生新的sndpkt，可以让接收方实现校验功能。   
`rdt2.0接收方`    
![rdt2.0接收方](\img\in-post\tcp_ip\rdt2-2.PNG)
与以前相比，接收方会将接收的sndpkt进行校验，并向发送方反馈。

**not finished**